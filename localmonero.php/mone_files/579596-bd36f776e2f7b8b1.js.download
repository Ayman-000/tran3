"use strict";(self.webpackChunk_N_E=self.webpackChunk_N_E||[]).push([[579596],{781292:function(t,e,a){a.d(e,{K:function(){return o}});var r=a(756082),n=a(439324),i=a(668031),s=a(963521),c=a(85841),l=a(653619),u=a(367088);let o=async(t,e)=>{(0,l.K0)(t,"encryptedSecret"),(0,l.RS)(e,32,"masterKey");let{encryptionType:a,b64iv:o,b64EncryptedSecretKey:h}=(0,r.J4)(t);if(parseInt(a)!==n.m)throw"ENCRYPTION_TYPE_MISMATCH_ERROR";if(!await (0,r.nj)(t,e))throw new u.Z("MAC_VERIFICATION_ERROR");let w=(0,i.I2)(o),f=(0,i.I2)(h),d=await (0,s.xc)(e,"enc");return await (0,c.yb)(f,d,w)}},85841:function(t,e,a){a.d(e,{AF:function(){return w},VB:function(){return u},_s:function(){return h},cN:function(){return c},nZ:function(){return l},yb:function(){return o}});var r=a(756082),n=a(963521),i=a(83652),s=a(781292);let c=async()=>await (0,r.O6)(32),l=async()=>await (0,r.O6)(16),u=async(t,e,a)=>{try{return await (0,r.RI)(t,e,a)}catch(t){console.error("Error while encrypting secret key",t)}},o=async(t,e,a)=>{try{return(0,r.VE)(t,e,a)}catch(t){throw console.error("Error while decrypting secret key",t),"ENCRYPTED_SECRET_DECRYPT_ERROR"}},h=async(t,e)=>{let a=await (0,n.Uc)(e,t),r=await (0,i.C)();return await (0,s.K)(r,a)},w=async(t,e,a)=>await (0,r.VE)(t,e,a)},83652:function(t,e,a){a.d(e,{C:function(){return s},u:function(){return i}});var r=a(506410),n=a(646615);let i=async t=>await (0,r.sC)(n.xL,t),s=async()=>{try{return await (0,r.ef)(n.xL)}catch(t){throw console.error("Error retrieving encrypted secret from storage",t),"SECRET_KEY_RETRIEVAL_ERROR"}}},207353:function(t,e,a){a.d(e,{pD:function(){return b},e6:function(){return R},Kf:function(){return m},RG:function(){return x},wT:function(){return E},SG:function(){return g},CO:function(){return v}});var r=a(413926),n=a(6884),i=a(422808),s=a(90963),c=a(668031);let l=t=>{let e=(0,c.YW)(t),a=e.slice(68,72);return 1e3*(0,c.tm)(a)};var u=a(197918),o=a(756082),h=a(529467),w=a(382282),f=a(330620);async function d(t,e){try{let a=new r.q(t,{verbose:!1}),n=performance.now(),{height:i}=await a.request("blockchain.headers.subscribe"),s=performance.now()-n;if((0,u.oq)(i,e))return{server:t,elapsed:s,client:a};throw Error("BAD_NODE")}catch(e){throw(0,f.H)(e,"pingServer ".concat(t)),e}}let y=async()=>{try{let t,e,a=await (0,i.Dr)("BTC"),r=await (0,u.ws)("BTC");return a.length>1?{server:t,client:e}=await (0,w.Pw)(a.map(t=>d(t,r)),3e4):t=a[0],{server:t,client:e}}catch(t){return(0,f.H)(t,"chooseElectrumServer"),await (0,w._v)(1e4),await y()}};class b{static async initialize(){let{server:t,client:e}=await y();return new b(t,e)}async request(t,e){return await this.client.request(t,...e)}async batchRequest(t){return await this.client.batchRequest(...t)}async requestTxHistoryForAddress(t){let e=await (0,s.he)(t);return await this.client.request("blockchain.scripthash.get_history",e)}async requestTxHistoriesForAddresses(t){let e=async t=>{let e=await (0,s.he)(t);return{method:"blockchain.scripthash.get_history",params:[e]}},a=t.map(e),r=await Promise.all(a);return await this.client.batchRequest(...r)}async subscribeToAddress(t,e){await this.client.subscribe("blockchain.scripthash",async(a,r)=>{await e(t,r)},await (0,s.he)(t))}async subscribeToBlockHeaders(t){await this.client.subscribe("blockchain.headers",async e=>{let{height:a}=e;await t(a)})}async broadcastTx(t){await this.request("blockchain.transaction.broadcast",t)}async close(t){await this.client.close(t)}async ping(){await this.client.request("server.ping")}constructor(t,e){this.client=null!=e?e:new r.q(t,{verbose:!1})}}let m=async(t,e,a)=>{try{let r=await (0,i.uu)(),n=p(Object.values(r)),s=await (0,i.hL)(),c=[];if(n.forEach(t=>{let e=s.find(e=>e.txId===t.tx_hash);e||c.push(t),t.height!==e.height&&c.push(t)}),!c.length)return null;return await (0,u.x8)(c,t,e,a)}catch(t){console.error("Error correcting discrepant txs",t)}},p=t=>{let e=[];return t.forEach(t=>t.forEach(t=>{e.some(e=>{let{tx_hash:a}=e;return a===t.tx_hash})||e.push(t)})),e},E=async(t,e)=>{let a=await e.requestTxHistoriesForAddresses(t);await (0,i.Cy)(C(t,a));let r=p(a),s=await g(r,e),c=await Promise.all(s.map(async(t,e)=>({height:r[e].height,...await (0,n.Zx)(t),txHex:t})));await (0,u.Ut)(c);let l=[],o=await (0,i.hL)();for(let t of c)l.push(await x(t,o));return(0,u.ve)(l),l},x=async(t,e)=>{let{txId:a,ins:r,outs:s,height:c}=t,{confirmations:l,isConfirmed:u}=(0,n.Hk)(c),o=0,w=0,f=[];for(let t of r){let a=(0,n._l)(t.txId,e);if(a){let e=a.outs[t.vout],{address:r,value:n}=e;r&&f.push(r),n?(null!==o&&(o+=n),(0,h.a)(r)&&(w+=n)):o=null}}let d=0,y=0,b=[];s.forEach(t=>{let{address:e,value:a}=t;e&&b.push(e),a&&(d+=a,(0,h.a)(e)&&(y+=a))});let m=y-w,p=0;o&&(p=o-d);let E=Date.now();if(c>0){let t=await (0,i.tH)();E=t[c]}f=[...new Set(f)],b=[...new Set(b)];let x={asset:"BTC",type:m>=0?"RECEIVE":"SEND",id:a,amount:m,fee:p,createdAt:E,confirmations:u?null:l,confirmed:u,fromAddresses:f,toAddresses:b};return x},g=async(t,e)=>{let a=t.map(t=>{let{tx_hash:e}=t;return{method:"blockchain.transaction.get",params:[e]}}),r=[...new Set(t.map(t=>{let{height:e}=t;return e}).filter(t=>t>0))],n=r.map(t=>({method:"blockchain.block.header",params:[t]})),s=await e.batchRequest([...a,...n]),c=s.slice(0,a.length);if(n.length){let t=s.slice(a.length),e={};t.forEach((t,a)=>{e[r[a]]=l(t)}),await (0,i.cG)(e)}return c},R=async t=>{let e=await (0,i.uu)(),a=e[t];if(!a||!a.length)return null;let r="";return a.forEach(t=>{let{tx_hash:e,height:a}=t;r+="".concat(e,":").concat(a,":")}),await (0,c.VM)(await (0,o.Wu)(r))},C=(t,e)=>{let a={};return t.forEach((t,r)=>{a[t]=e[r]}),a},v=async(t,e)=>{let a=Object.keys(await (0,i.uu)()),r=async a=>{await e.subscribeToAddress(a,t)},n=a.map(r);await Promise.all(n)}},197918:function(t,e,a){a.d(e,{Ss:function(){return _},oq:function(){return k},Rf:function(){return B},ws:function(){return S},zf:function(){return x},x8:function(){return E},Em:function(){return R},ve:function(){return C},Lm:function(){return g},Od:function(){return m},a$:function(){return T},Ut:function(){return N},BJ:function(){return I}});var r=a(90963),n=a(813012),i=a(193396),s=a(422808),c=a(750880);let l=async(t,e)=>{try{let a={txs:[]};for(let r of t){let t,s;let{fee:l,numConfirmations:o,hash:h,isOutgoing:w,incomingTransfers:f,outgoingTransfer:d,block:y}=r,b=u([d]);t=w?u(null==d?void 0:d.destinations):u(f),t=[...new Set(t)],b=[...new Set(b)],w?f?s=new n.Z(l.toString()).neg().toNumber():(s=new n.Z(d.amount.toString()).plus(l.toString()),s=await e.getExternallySentAmount(r,s),s=new n.Z(s).neg().toNumber()):s=(0,c.d4)(f.map(t=>t),"amount");let m=Date.now();y&&(m=(null==y?void 0:y.timestamp)*1e3);let p=null;if(w)try{p=await e.getTxKey(h)}catch(t){}let E={asset:"XMR",type:w?"SEND":"RECEIVE",id:h,amount:s,fee:new n.Z(l.toString()).toNumber(),createdAt:m,confirmations:o,confirmed:o>=i.rA.XMR,fromAddresses:b,toAddresses:t,txKey:p};a.txs.push(E)}return a}catch(t){throw console.error("Error consuming Monero daemon response",t),t}},u=t=>{try{if(!(null==t?void 0:t.length))return[];return t.map(t=>{let{address:e}=t;return e}).filter(t=>!!t)}catch(t){return[]}};var o=a(207353),h=a(346194),w=a(132286),f=a(6884),d=a(506410),y=a(646615),b=a(752506);let m=async(t,e,a)=>{let n=[],c=-1,l=-1,u=0,h=0,w=0,f=!1,d=!1,y=async()=>{let a=1;switch(w){case 0:await (0,s.wX)([]);break;case 1:a=10;break;case 2:a=25;break;case 3:a=50;break;default:a=100}let b=[];if(!d){let e=a+i.zh;b.push(...await (0,r.A_)(t,e,h,1,"BTC")),h+=e}let m=[];if(!f){let e=a+i.zh;m.push(...await (0,r.A_)(t,e,u,0,"BTC")),u+=e}let p=[...m,...b],E=await (0,o.wT)(p,e),x=(0,r.jt)(E),g=(0,r.Cf)(m,x),R=(0,r.Cf)(b,x);n.push(...E),g>=0&&(c=c+=g+1),R>=0&&(l=l+=R+1),f||(f=m.length-1>=g+i.zh),d=b.length-1>=R+i.zh,f&&d?(c>=0&&(t.externalWalletChainLastUsedAddressIndex=c+1),l>=0&&(t.internalWalletChainLastUsedAddressIndex=l+1)):(w++,await y())};return await y(),v(n,t,a)},p=(t,e,a)=>{let r=[];return t.forEach((t,n)=>{let i=e.find(e=>t[a]===e[a]);i?r.push(i):r.push(t)}),e.forEach(e=>{t.find(t=>e[a]===t[a])||r.push(e)}),r},E=async(t,e,a,r)=>{let n=await (0,o.SG)(t,a),i=await Promise.all(n.map(async(e,a)=>({height:t[a].height,...await (0,f.Zx)(e),txHex:e})));return await x(i,e,r)},x=async(t,e,a)=>{await N(t);let n=[],i=await (0,s.hL)();for(let e of t)n.push(await (0,o.RG)(e,i));let c=await (0,s.VH)(),l=p(c,n,"id");C(l);let u=(0,r.jt)(n),{walletExternalAddresses:h,walletInternalAddresses:w}=await A(e),f=(0,r.Cf)(h,u);f>=0&&(e.externalWalletChainLastUsedAddressIndex=f+1);let d=(0,r.Cf)(w,u);return d>=0&&(e.internalWalletChainLastUsedAddressIndex=d+1),v(l,e,a)},g=async(t,e,a,r)=>{let n=await a.requestTxHistoryForAddress(t),i=await (0,s.uu)(),c=i[t];await (0,s.Cy)({[t]:n});let l=n.filter(t=>{let{tx_hash:e,height:a}=t;return!c.some(t=>e===t.tx_hash&&a===t.height)});return await E(l,e,a,r)},R=async(t,e)=>{try{let a=[],r=await (0,s.hL)();for(let t of r)a.push(await (0,o.RG)(t,r));return v(a,t,e)}catch(t){console.error("Error reprocessDecodedTxsIntoWalletData",t)}},C=function(t){let e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:"createdAt";(0,c.IK)(t,e,"desc")},v=async(t,e,a)=>{let r={txs:[],utxos:[],balance:0,unconfirmedBalance:0,receiveAddress:await e.createReceive()};if(t.length){let e=await (0,s.hL)();for(let a of t){let t=r.txs.findIndex(t=>{let{id:e}=t;return e===a.id});if(-1===t)r.txs.push(a);else{let n=e.find(t=>{let{txId:e}=t;return e===a.id});r.txs[t]=await (0,o.RG)(n,e)}}}r.utxos=await (0,h.ZB)();let{confirmedBalance:i,unconfirmedBalance:l}=await (0,w.JJ)(e,r.utxos);r.balance=i,r.unconfirmedBalance=l;let{totalReservedBalance:u}=await (0,w.dX)("BTC",a);u=(0,c.NF)(u,"BTC");let f=new n.Z(i).minus(u).toNumber();return r.reservedBalance=u,r.balanceAvailable=f,r.totalBalance=new n.Z(i).plus(l).toNumber(),C(r.txs),await (0,s.CG)(r.txs),r},A=async t=>{let e=t.externalWalletChainLastUsedAddressIndex,a=t.internalWalletChainLastUsedAddressIndex;if(isNaN(e)||isNaN(a))throw"SYNC_ADDRESS_INDEX_ERROR";let n=await (0,r.A_)(t,e+i.zh,0,0,"BTC"),s=await (0,r.A_)(t,a+i.zh,0,1,"BTC");return{walletExternalAddresses:n,walletInternalAddresses:s}},T=async(t,e)=>{let{newBlockReceived:a,newOutputReceived:r}=await t.sync(),i=await t.getTxs(),u=await (0,s.ro)();if(u.length){let t=u.filter(t=>i.some(e=>e.hash===t.hash)),e=u.filter(e=>!t.some(t=>t.hash===e.hash));t.length&&await (0,s.Ev)(t),i=[...i,...e]}let{txs:o}=await l(i,t);C(o);let h=await t.getReceiveAddress(),{balance:f,unlockedBalance:d}=await t.getBalances(),y=new n.Z(f).minus(d).toNumber(),{totalReservedBalance:b}=await (0,w.dX)("XMR",e,t);b=(0,c.NF)(b,"XMR");let m=new n.Z(d).minus(b).toNumber();return[{txs:o,receiveAddress:h,balance:d,unconfirmedBalance:y,balanceAvailable:m,totalBalance:f,reservedBalance:b},a,r]},_=(t,e,a)=>{let r=(0,c.NF)(e.balanceAvailable,a),i=new n.Z(r).eq(t.balanceAvailable);return i},I=async(t,e)=>{let a=await (0,s.I8)(t);a&&Object.keys(a).length>1&&e(a)},N=async t=>{await (0,d.Gf)(y.cJ,e=>(e||(e=[]),p(e,t,"txId")))},S=async t=>{let{height:e}=await (0,b.Z)({url:"/web/height/".concat(t)});return e},k=(t,e)=>e-t<=i.ak,B=async t=>{let e=await (0,b.Z)({url:"/web/nodes/".concat(t)});await (0,s.EP)(t,e)}}}]);